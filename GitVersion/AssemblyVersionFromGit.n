using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using System.IO;
using System.Globalization;
using System.Text.RegularExpressions;
using Nemerle.Extensions;

namespace GitVersion
{
  [Nemerle.MacroUsage (Nemerle.MacroPhase.BeforeInheritance,
                       Nemerle.MacroTargets.Assembly)]
  macro AssemblyVersionFromGit(version : string, fallbackToDate : bool = true)
  {
    def version =
      if (version.IndexOf ("Git", System.StringComparison.InvariantCultureIgnoreCase) >= 0) 
      {
        def myLoc = Nemerle.Compiler.LocationStack.Top();
        def path = if (myLoc.IsSourceFileAvailable)
                     Path.GetDirectoryName(Path.GetFullPath (myLoc.File))
                   else
                     Directory.GetCurrentDirectory();

        def getFallbackRev()
        {
          (DateTime.Now.Year % 100).ToString () + DateTime.Now.DayOfYear.ToString ("000")
        }
        
        def gitResult = 
          try
          {
            GitRevisionHelper.GetRevisionGeneric(path)
          }
          catch
          {
            | e =>
              Message.Warning(myLoc, e.Message);
              None()
          }
        
        match (gitResult)
        {
          | None() when !fallbackToDate =>
            Message.FatalError (myLoc, "could not obtain revision from Git metadata");

          | None() with (tag = "NoGitTag", rev = getFallbackRev(), commit = "NoGitHash")
          | Some( (tag, rev, commit) ) =>
            version
              .Replace("GitTag", tag)
              .Replace("GitRev", rev)
              .Replace("GitHash", commit)
        }
      }
      else 
        version;

    Nemerle.Macros.Manager().Hierarchy.AddAssemblyAttribute (Nemerle.Macros.Manager().CoreEnv,
      <[ System.Reflection.AssemblyVersion ($(version : string)) ]>);
  }

  module GitRevisionHelper
  {
    public GetRevisionGeneric(path : string) : option[string * string * string]
    {
      // Execute "git describe"
      def process = System.Diagnostics.Process();
      process.StartInfo.UseShellExecute = false;
      process.StartInfo.FileName = "git";
      process.StartInfo.Arguments = "describe --tags --long";
      process.StartInfo.RedirectStandardOutput = true;
      process.StartInfo.RedirectStandardError = true;
      process.StartInfo.WorkingDirectory = path;

      // Read git output line by line until regex is matched
      def loop(reader) 
      {
        match (reader.ReadLine()) 
        {
          | null => 
            None()
          | line =>
            def regex = Regex(@"(?<tag>.+)\-(?<rev>.+)\-(?<commit>.+)");
            def mc = regex.Match(line);

            if (mc.Success)
            {
              def tag = Regex.Replace(mc.Groups["tag"].Value, @"[^\d\.]", "");
              def rev = mc.Groups["rev"].Value;
              def commit = mc.Groups["commit"].Value;
                    
              Some(tag, rev, commit);
            }
            else
            {
              loop(reader);
            }
        }
      }

      try
      {
        _ = process.Start();

        def revision = loop (process.StandardOutput);

        // Wait for git client process to terminate
        unless (process.WaitForExit (2000))
          process.Kill ();

        revision;
      }
      catch
      {
        | _ => None();
      }
    }
  }
}
